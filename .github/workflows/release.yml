---
# Release workflow for cleared project
# This workflow handles version bumping, tagging, GitHub releases, and PyPI publishing
name: Release

# Controls when the workflow will run
on:
  # Manual trigger with version bump type selection
  workflow_dispatch:
    inputs:
      version_bump:
        description: 'Version bump type'
        required: true
        type: choice
        options:
          - patch
          - minor
          - major
      publish_to_pypi:
        description: 'Publish to PyPI'
        required: true
        type: boolean
        default: true
      create_release:
        description: 'Create GitHub release'
        required: true
        type: boolean
        default: true

# Environment variables
env:
  PYTHON_VERSION: '3.11'

jobs:
  # Job 1: Prepare release - bump version, run tests, build
  prepare-release:
    name: "Prepare Release"
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
    outputs:
      version: ${{ steps.version_bump.outputs.new_version }}
      version_tag: ${{ steps.version_bump.outputs.version_tag }}
      release_branch: ${{ steps.commit_version.outputs.release_branch }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Fetch all history for tags and changelog
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up Python ${{ env.PYTHON_VERSION }}
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Install Task runner
        uses: arduino/setup-task@v1
        with:
          version: 3.x

      - name: Install Poetry
        uses: snok/install-poetry@v1
        with:
          version: latest
          virtualenvs-create: true
          virtualenvs-in-project: true

      - name: Install OS dependencies
        run: task install-os-deps

      - name: Install dependencies
        run: task setup-env-ci

      - name: Configure Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git remote set-url origin \
            https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}.git

      - name: Checkout main branch for version bump
        if: github.event_name == 'workflow_dispatch'
        run: |
          # Get the default branch name (usually 'main' or 'master')
          DEFAULT_BRANCH="${{ github.event.repository.default_branch }}"
          if [ -z "${DEFAULT_BRANCH}" ]; then
            DEFAULT_BRANCH="main"
          fi
          echo "Checking out ${DEFAULT_BRANCH} branch for version bump..."
          git fetch origin ${DEFAULT_BRANCH}
          git checkout ${DEFAULT_BRANCH}
          git pull origin ${DEFAULT_BRANCH}

      - name: Get current version
        id: current_version
        run: |
          CURRENT_VERSION=$(cat VERSION)
          echo "current_version=${CURRENT_VERSION}" >> "$GITHUB_OUTPUT"
          echo "Current version: ${CURRENT_VERSION}"

      - name: Bump version
        id: version_bump
        if: github.event_name == 'workflow_dispatch'
        run: |
          BUMP_TYPE="${{ github.event.inputs.version_bump }}"
          echo "Bumping version: ${BUMP_TYPE}"
          
          # Use task to bump version (using -- separator to pass argument)
          task version-bump -- ${BUMP_TYPE}
          
          # Get new version
          NEW_VERSION=$(cat VERSION)
          VERSION_TAG="v${NEW_VERSION}"
          
          # Verify version was updated in pyproject.toml
          PYPROJECT_VERSION=$(poetry version --short)
          if [ "${PYPROJECT_VERSION}" != "${NEW_VERSION}" ]; then
            echo "ERROR: Version mismatch!"
            echo "VERSION file: ${NEW_VERSION}"
            echo "pyproject.toml: ${PYPROJECT_VERSION}"
            exit 1
          fi
          
          echo "Verified: pyproject.toml version is ${PYPROJECT_VERSION}"
          echo "new_version=${NEW_VERSION}" >> "$GITHUB_OUTPUT"
          echo "version_tag=${VERSION_TAG}" >> "$GITHUB_OUTPUT"
          echo "New version: ${NEW_VERSION}"
          echo "Version tag: ${VERSION_TAG}"

      - name: Run full CI checks
        if: github.event_name == 'workflow_dispatch'
        run: |
          echo "Running CI checks before release..."
          task ci-local

      - name: Generate changelog
        id: changelog
        if: github.event_name == 'workflow_dispatch'
        continue-on-error: true
        run: |
          echo "Generating changelog..."
          task changelog || echo "Changelog generation completed (or no changes to log)"
          
          # Read changelog content if it exists
          if [ -f CHANGELOG.md ]; then
            CHANGELOG_CONTENT=$(cat CHANGELOG.md)
            # Use multiline output
            {
              echo "changelog<<EOF"
              echo "${CHANGELOG_CONTENT}"
              echo "EOF"
            } >> "$GITHUB_OUTPUT"
          else
            echo "changelog=No changelog generated" >> "$GITHUB_OUTPUT"
          fi

      - name: Build distribution packages
        run: |
          echo "Building distribution packages..."
          
          # Verify README.md exists (required for PyPI package description)
          if [ ! -f "README.md" ]; then
            echo "ERROR: README.md not found in current directory!"
            echo "Current directory: $(pwd)"
            echo "Files in current directory:"
            ls -la
            exit 1
          fi
          echo "README.md found: $(ls -lh README.md)"
          
          # Verify version before building
          EXPECTED_VERSION="${{ steps.version_bump.outputs.new_version }}"
          if [ -n "${EXPECTED_VERSION}" ]; then
            ACTUAL_VERSION=$(poetry version --short)
            echo "Expected version: ${EXPECTED_VERSION}"
            echo "Actual version in pyproject.toml: ${ACTUAL_VERSION}"
            if [ "${ACTUAL_VERSION}" != "${EXPECTED_VERSION}" ]; then
              echo "ERROR: Version mismatch before build!"
              exit 1
            fi
          fi
          
          # Verify pyproject.toml has readme configured
          if ! grep -q 'readme.*=.*"README.md"' pyproject.toml && \
             ! grep -q "readme.*=.*'README.md'" pyproject.toml; then
            echo "WARNING: pyproject.toml may not have readme configured correctly"
            echo "Checking pyproject.toml for readme:"
            grep -i readme pyproject.toml || echo "No readme found in pyproject.toml"
          fi
          
          # Build packages
          task build
          
          # Verify built packages
          ls -la dist/
          echo "Checking if README.md is included in source distribution..."
          for tarball in dist/*.tar.gz; do
            if [ -f "${tarball}" ]; then
              tar -tzf "${tarball}" | grep -i readme || \
                echo "WARNING: README.md not found in source distribution"
              break
            fi
          done

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: dist-packages
          path: dist/
          retention-days: 7

      - name: Create release branch and commit version changes
        id: commit_version
        if: github.event_name == 'workflow_dispatch'
        run: |
          NEW_VERSION="${{ steps.version_bump.outputs.new_version }}"
          RELEASE_BRANCH="release/version-${NEW_VERSION}"
          
          # Create release branch from current branch (main)
          echo "Creating release branch: ${RELEASE_BRANCH}"
          git checkout -b "${RELEASE_BRANCH}"
          
          # Stage and commit version changes
          git add VERSION pyproject.toml CHANGELOG.md
          git commit -m "chore: bump version to ${NEW_VERSION}" \
            || echo "No changes to commit"
          
          # Push release branch
          echo "Pushing release branch: ${RELEASE_BRANCH}"
          git push origin "${RELEASE_BRANCH}" || {
            echo "⚠️  Failed to push release branch. It may already exist."
            # Check if branch exists remotely
            if git ls-remote --heads origin "${RELEASE_BRANCH}" | grep -q "${RELEASE_BRANCH}"; then
              echo "✅ Release branch already exists remotely"
            else
              echo "❌ Release branch does not exist and push failed"
              exit 1
            fi
          }
          
          # Output release branch name for use in create-pr job
          echo "release_branch=${RELEASE_BRANCH}" >> "$GITHUB_OUTPUT"
          echo "✅ Created and pushed release branch: ${RELEASE_BRANCH}"

      - name: Create and push tag
        if: github.event_name == 'workflow_dispatch' && github.event.inputs.create_release == 'true'
        run: |
          TAG="${{ steps.version_bump.outputs.version_tag }}"
          echo "Creating tag: ${TAG}"
          git tag -a "${TAG}" -m "Release ${TAG}"
          git push origin "${TAG}"

  # Job 2: Create GitHub Release
  create-release:
    name: "Create GitHub Release"
    needs: prepare-release
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch' && github.event.inputs.create_release == 'true'
    permissions:
      contents: write
    outputs:
      release_created: ${{ steps.set_release_output.outputs.release_created }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Download artifacts
        uses: actions/download-artifact@v4
        with:
          name: dist-packages
          path: dist/

      - name: Generate release notes
        id: release_notes
        run: |
          TAG="${{ needs.prepare-release.outputs.version_tag }}"
          
          # Try to get changelog section for this version
          if [ -f CHANGELOG.md ]; then
            # Extract recent changelog entries (first 100 lines usually contain latest)
            RELEASE_NOTES=$(head -100 CHANGELOG.md)
          else
            # Fallback: use git log
            PREVIOUS_TAG=$(git tag --sort=-creatordate | sed -n 2p)
            if [ -z "${PREVIOUS_TAG}" ]; then
              RELEASE_NOTES="## Release ${TAG}

              Initial release or changelog not available."
            else
              RELEASE_NOTES=$(git log "${PREVIOUS_TAG}"..HEAD --pretty=format:"- %s (%h)" --no-merges)
              RELEASE_NOTES="## Release ${TAG}

              ### Changes since ${PREVIOUS_TAG}:

              ${RELEASE_NOTES}"
            fi
          fi
          
          # Use multiline output
          {
            echo "notes<<EOF"
            echo "${RELEASE_NOTES}"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"

      - name: Create GitHub Release
        id: create_release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ needs.prepare-release.outputs.version_tag }}
          name: Release ${{ needs.prepare-release.outputs.version_tag }}
          body: ${{ steps.release_notes.outputs.notes }}
          files: dist/*
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        continue-on-error: true
      
      - name: Set release created output
        id: set_release_output
        if: steps.create_release.outcome == 'success'
        run: |
          echo "release_created=true" >> "$GITHUB_OUTPUT"

  # Job 3: Publish to PyPI
  publish-pypi:
    name: "Publish to PyPI"
    needs: prepare-release
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch' && github.event.inputs.publish_to_pypi == 'true'
    environment:
      name: pypi
      url: https://pypi.org/p/cleared
    permissions:
      contents: read
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python ${{ env.PYTHON_VERSION }}
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
      
      - name: Install Task runner
        uses: arduino/setup-task@v1
        with:
          version: 3.x

      - name: Install Poetry
        uses: snok/install-poetry@v1
        with:
          version: latest
          virtualenvs-create: true
          virtualenvs-in-project: true

      - name: Install dependencies
        run: task setup-env-ci
    
      - name: Verify version matches prepare-release
        run: |
          # Get expected version from prepare-release job outputs
          EXPECTED_VERSION="${{ needs.prepare-release.outputs.version }}"
          
          if [ -z "${EXPECTED_VERSION}" ]; then
            echo "❌ ERROR: No version found from prepare-release job outputs"
            exit 1
          fi
          
          echo "Expected version from prepare-release: ${EXPECTED_VERSION}"
          
          # Checkout the release branch that was created in prepare-release
          # This ensures we have the version-bumped code
          RELEASE_BRANCH="${{ needs.prepare-release.outputs.release_branch }}"
          if [ -n "${RELEASE_BRANCH}" ]; then
            echo "Checking out release branch: ${RELEASE_BRANCH}"
            git fetch origin "${RELEASE_BRANCH}"
            git checkout "${RELEASE_BRANCH}"
          else
            echo "⚠️  No release branch found, using current checkout"
          fi
          
          # Verify version in files matches expected version
          ACTUAL_VERSION=$(cat VERSION)
          PYPROJECT_VERSION=$(poetry version --short)
          
          echo "VERSION file: ${ACTUAL_VERSION}"
          echo "pyproject.toml: ${PYPROJECT_VERSION}"
          echo "Expected: ${EXPECTED_VERSION}"
          
          if [ "${ACTUAL_VERSION}" != "${EXPECTED_VERSION}" ]; then
            echo "❌ ERROR: VERSION file mismatch!"
            echo "Expected: ${EXPECTED_VERSION}"
            echo "Actual: ${ACTUAL_VERSION}"
            exit 1
          fi
          
          if [ "${PYPROJECT_VERSION}" != "${EXPECTED_VERSION}" ]; then
            echo "❌ ERROR: pyproject.toml version mismatch!"
            echo "Expected: ${EXPECTED_VERSION}"
            echo "Actual: ${PYPROJECT_VERSION}"
            exit 1
          fi
          
          echo "✅ Verified: Version matches prepare-release (${EXPECTED_VERSION})"

      - name: Build distribution packages
        run: |
          echo "Building distribution packages..."
          task build

      - name: Verify packages exist
        run: |
          echo "Checking for distribution packages..."
          echo "Current directory: $(pwd)"
          ls -la dist/ || echo "dist/ directory not found"
          echo "Package files:"
          find dist/ -type f \( -name "*.whl" -o -name "*.tar.gz" \) 2>/dev/null || echo "No matching files found"
          if [ -d "dist/" ]; then
            echo "Contents of dist/:"
            ls -lah dist/
          fi

      - name: Verify README.md in package matches project README.md
        run: |
          echo "Verifying README.md in distribution package..."
          
          # Find the source distribution tar.gz file
          TARBALL=""
          for file in dist/*.tar.gz; do
            if [ -f "${file}" ]; then
              TARBALL="${file}"
              break
            fi
          done
          
          if [ -z "${TARBALL}" ]; then
            echo "❌ ERROR: No .tar.gz file found in dist/"
            exit 1
          fi
          
          echo "Found source distribution: ${TARBALL}"
          
          # Verify project README.md exists
          if [ ! -f "README.md" ]; then
            echo "❌ ERROR: Project README.md not found!"
            exit 1
          fi
          
          # Extract README.md from the tarball
          TEMP_DIR=$(mktemp -d)
          echo "Extracting README.md from package..."
          
          # Extract the entire package first, then access README.md
          # The package structure is: cleared-X.Y.Z/README.md
          PACKAGE_NAME=$(basename "${TARBALL}" .tar.gz)
          
          if ! tar -xzf "${TARBALL}" -C "${TEMP_DIR}" "${PACKAGE_NAME}/README.md" 2>&1; then
            echo "❌ ERROR: Failed to extract README.md from package"
            echo "Contents of package:"
            tar -tzf "${TARBALL}" | head -20
            rm -rf "${TEMP_DIR}"
            exit 1
          fi
          
          PACKAGED_README="${TEMP_DIR}/${PACKAGE_NAME}/README.md"
          
          if [ ! -f "${PACKAGED_README}" ]; then
            echo "❌ ERROR: README.md not found in package!"
            echo "Contents of package:"
            tar -tzf "${TARBALL}" | grep -i readme || echo "No README files found"
            echo "Extracted files in temp dir:"
            find "${TEMP_DIR}" -type f | head -10
            rm -rf "${TEMP_DIR}"
            exit 1
          fi
          
          echo "✅ README.md found in package"
          
          # Compare the two README.md files
          if diff -q "README.md" "${PACKAGED_README}" > /dev/null 2>&1; then
            echo "✅ Verified: README.md in package matches project README.md"
            echo "First 5 lines of project README.md:"
            head -5 README.md
            echo ""
            echo "First 5 lines of packaged README.md:"
            head -5 "${PACKAGED_README}"
          else
            echo "❌ ERROR: README.md in package does NOT match project README.md!"
            echo ""
            echo "Differences found:"
            diff -u "README.md" "${PACKAGED_README}" | head -50 || true
            echo ""
            echo "Project README.md size: $(wc -l < README.md) lines"
            echo "Packaged README.md size: $(wc -l < "${PACKAGED_README}") lines"
            rm -rf "${TEMP_DIR}"
            exit 1
          fi
          
          # Cleanup
          rm -rf "${TEMP_DIR}"
          echo "✅ README.md verification passed!"

      - name: Publish to PyPI
        env:
          TWINE_USERNAME: __token__
          TWINE_PASSWORD: ${{ secrets.PYPI_API_TOKEN }}
        run: |
          echo "Publishing to PyPI..."
          echo "Current directory: $(pwd)"
          echo "Checking dist/ directory:"
          ls -la dist/ || echo "dist/ directory does not exist"
          
          # Check if packages exist
          PACKAGES_FOUND=false
          for file in dist/*.whl dist/*.tar.gz; do
            if [ -f "${file}" ]; then
              PACKAGES_FOUND=true
              echo "Found package: ${file}"
            fi
          done
          
          if [ "${PACKAGES_FOUND}" = "false" ]; then
            echo "Error: No distribution packages found in dist/"
            echo "Contents of current directory:"
            ls -la
            echo "Looking for dist directory:"
            find . -type d -name "dist" 2>/dev/null || echo "No dist directory found"
            exit 1
          fi
          
          # Publish using twine (more reliable for pre-built packages)
          poetry run twine upload dist/* || {
            echo "Publishing failed. This might be because:"
            echo "  - The version already exists on PyPI"
            echo "  - PyPI API token is invalid"
            echo "  - Network issues"
            echo ""
            echo "Check PyPI to verify if the version exists."
            exit 1
          }
          echo "Successfully published to PyPI!"

  # Job 4: Create PR after all jobs succeed
  create-pr:
    name: "Create Pull Request"
    needs: [prepare-release, create-release, publish-pypi]
    runs-on: ubuntu-latest
    if: |
      github.event_name == 'workflow_dispatch' &&
      always() &&
      needs.prepare-release.result == 'success' &&
      (needs.create-release.result == 'success' ) &&
      (needs.publish-pypi.result == 'success' )
    permissions:
      contents: write
      pull-requests: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Create Pull Request
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Get default branch name
          DEFAULT_BRANCH="${{ github.event.repository.default_branch }}"
          if [ -z "${DEFAULT_BRANCH}" ]; then
            DEFAULT_BRANCH="main"
          fi
          
          # Get version from prepare-release outputs
          NEW_VERSION="${{ needs.prepare-release.outputs.version }}"
          
          if [ -z "${NEW_VERSION}" ]; then
            echo "No version found, skipping PR creation"
            exit 0
          fi
          
          # Get release branch name from prepare-release outputs
          RELEASE_BRANCH="${{ needs.prepare-release.outputs.release_branch }}"
          if [ -z "${RELEASE_BRANCH}" ]; then
            RELEASE_BRANCH="release/version-${NEW_VERSION}"
          fi
          
          echo "Creating pull request to merge version bump into ${DEFAULT_BRANCH}..."
          echo "Release branch: ${RELEASE_BRANCH}"
          echo "New version: ${NEW_VERSION}"
          
          # Verify release branch exists
          if ! git ls-remote --heads origin "${RELEASE_BRANCH}" | grep -q "${RELEASE_BRANCH}"; then
            echo "❌ ERROR: Release branch ${RELEASE_BRANCH} does not exist!"
            echo "Cannot create PR without the branch. Exiting."
            exit 1
          fi
          echo "✅ Verified release branch exists: ${RELEASE_BRANCH}"
          
          # Use GitHub REST API to create PR (more reliable than gh CLI)
          PR_TITLE="chore: bump version to ${NEW_VERSION}"
          PR_BODY="Automated version bump to ${NEW_VERSION} as part of release workflow.

          This PR was automatically created after a successful release. All release jobs completed successfully:
          - ✅ Version bumped and packages built
          - ✅ GitHub release created
          - ✅ PyPI package published
          
          Please review and merge to update the version on the main branch."
          
          # Create PR using GitHub REST API
          PR_RESPONSE=$(curl -s -w "\n%{http_code}" -X POST \
            -H "Accept: application/vnd.github+json" \
            -H "Authorization: Bearer ${GITHUB_TOKEN}" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "https://api.github.com/repos/${{ github.repository }}/pulls" \
            -d "{
              \"title\": \"${PR_TITLE}\",
              \"body\": $(echo "${PR_BODY}" | jq -Rs .),
              \"head\": \"${RELEASE_BRANCH}\",
              \"base\": \"${DEFAULT_BRANCH}\"
            }")
          
          HTTP_CODE=$(echo "${PR_RESPONSE}" | tail -n1)
          PR_JSON=$(echo "${PR_RESPONSE}" | head -n-1)
          
          if [ "${HTTP_CODE}" = "201" ]; then
            PR_NUMBER=$(echo "${PR_JSON}" | jq -r '.number')
            PR_URL=$(echo "${PR_JSON}" | jq -r '.html_url')
            echo "✅ Successfully created PR #${PR_NUMBER}: ${PR_URL}"
            
            # Try to add 'release' label if it exists (don't fail if it doesn't)
            LABEL_RESPONSE=$(curl -s -w "\n%{http_code}" -X POST \
              -H "Accept: application/vnd.github+json" \
              -H "Authorization: Bearer ${GITHUB_TOKEN}" \
              -H "X-GitHub-Api-Version: 2022-11-28" \
              "https://api.github.com/repos/${{ github.repository }}/issues/${PR_NUMBER}/labels" \
              -d '["release"]' 2>&1)
            
            LABEL_HTTP_CODE=$(echo "${LABEL_RESPONSE}" | tail -n1)
            if [ "${LABEL_HTTP_CODE}" = "200" ] || [ "${LABEL_HTTP_CODE}" = "201" ]; then
              echo "✅ Added 'release' label to PR"
            else
              echo "⚠️  Could not add 'release' label (may not exist or already added)"
            fi
            
            echo "::notice::Pull request created for version ${NEW_VERSION}. Please merge to update main branch."
            echo "::notice::PR URL: ${PR_URL}"
          elif [ "${HTTP_CODE}" = "422" ]; then
            # Check if PR already exists
            EXISTING_PR=$(curl -s \
              -H "Accept: application/vnd.github+json" \
              -H "Authorization: Bearer ${GITHUB_TOKEN}" \
              -H "X-GitHub-Api-Version: 2022-11-28" \
              "https://api.github.com/repos/${{ github.repository }}/pulls?head=${{ github.repository_owner }}:${RELEASE_BRANCH}&state=open" | \
              jq -r '.[0].number // empty')
            
            if [ -n "${EXISTING_PR}" ]; then
              echo "✅ PR #${EXISTING_PR} already exists for this branch"
            else
              echo "❌ PR creation failed:"
              echo "${PR_JSON}" | jq -r '.message // .' || echo "${PR_JSON}"
              exit 1
            fi
          else
            echo "❌ Failed to create pull request (HTTP ${HTTP_CODE}):"
            echo "${PR_JSON}" | jq -r '.message // .' || echo "${PR_JSON}"
            exit 1
          fi

  # Job 5: Rollback on failure
  rollback:
    name: "Rollback Release"
    needs: [prepare-release, create-release, publish-pypi]
    runs-on: ubuntu-latest
    if: |
      github.event_name == 'workflow_dispatch' &&
      always() &&
      needs.prepare-release.result == 'success' &&
      (needs.create-release.result == 'failure' || needs.publish-pypi.result == 'failure')
    permissions:
      contents: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up Python ${{ env.PYTHON_VERSION }}
        if: needs.publish-pypi.result == 'success'
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
      
      - name: Install Task runner
        uses: arduino/setup-task@v1
        with:
          version: 3.x

      - name: Install Poetry
        if: needs.publish-pypi.result == 'success'
        uses: snok/install-poetry@v1
        with:
          version: latest
          virtualenvs-create: true
          virtualenvs-in-project: true

      - name: Install dependencies
        if: needs.publish-pypi.result == 'success'
        run: task setup-env-ci

      - name: Configure Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git remote set-url origin \
            https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}.git

      - name: Rollback Git Tag
        if: |
          needs.prepare-release.result == 'success' &&
          (needs.create-release.result == 'failure' || needs.publish-pypi.result == 'failure')
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          VERSION_TAG="${{ needs.prepare-release.outputs.version_tag }}"
          
          if [ -z "${VERSION_TAG}" ]; then
            echo "No version tag to rollback"
            exit 0
          fi
          
          echo "Attempting to delete tag: ${VERSION_TAG}"
          echo "Tag was created successfully in prepare-release, but create-release or publish-pypi failed"
          
          # Check if tag exists on remote (it should exist since prepare-release succeeded)
          git fetch --tags
          if git rev-parse "refs/tags/${VERSION_TAG}" >/dev/null 2>&1; then
            echo "Deleting remote tag: ${VERSION_TAG}"
            git push origin --delete "${VERSION_TAG}" || echo "Failed to delete tag"
          else
            echo "Tag ${VERSION_TAG} does not exist on remote (may have been deleted already)"
          fi

      - name: Rollback GitHub Release
        if: |
          (needs.create-release.outputs.release_created == 'true' || 
           (needs.create-release.result == 'failure' && github.event.inputs.create_release == 'true')) &&
          (needs.create-release.result == 'failure' || needs.publish-pypi.result == 'failure')
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          VERSION_TAG="${{ needs.prepare-release.outputs.version_tag }}"
          
          if [ -z "${VERSION_TAG}" ]; then
            echo "No version tag, skipping release deletion"
            exit 0
          fi
          
          echo "Attempting to delete GitHub release for tag: ${VERSION_TAG}"
          echo "Release was created successfully in create-release, but create-release or publish-pypi failed"
          
          # Check if release exists (it should exist if the step succeeded)
          if gh release view "${VERSION_TAG}" >/dev/null 2>&1; then
            echo "Deleting GitHub release: ${VERSION_TAG}"
            gh release delete "${VERSION_TAG}" --yes || echo "Failed to delete release"
          else
            echo "Release ${VERSION_TAG} does not exist (may not have been created or already deleted)"
          fi

      - name: Rollback PyPI Package
        if: |
          needs.publish-pypi.result == 'success' &&
          needs.create-release.result == 'failure'
        env:
          TWINE_USERNAME: __token__
          TWINE_PASSWORD: ${{ secrets.PYPI_API_TOKEN }}
        run: |
          NEW_VERSION="${{ needs.prepare-release.outputs.version }}"
          
          if [ -z "${NEW_VERSION}" ]; then
            echo "No version found, skipping PyPI rollback"
            exit 0
          fi
          
          echo "Attempting to yank PyPI package version: ${NEW_VERSION}"
          echo "PyPI publish succeeded but GitHub release failed. Yanking package to prevent new installs."
          echo "Note: PyPI does not allow deleting packages, only yanking them."
          echo "Yanking prevents new installs but keeps existing installations working."
          
          # Yank the package version
          poetry run twine yank cleared==${NEW_VERSION} --yes || {
            echo "Failed to yank package. This might be because:"
            echo "  - The package version doesn't exist on PyPI"
            echo "  - PyPI API token is invalid"
            echo "  - Network issues"
            echo ""
            echo "You may need to manually yank the package on PyPI:"
            echo "  twine yank cleared==${NEW_VERSION} --yes"
            exit 1
          }
          
          echo "Successfully yanked cleared==${NEW_VERSION} from PyPI"

      - name: Report Rollback Status
        run: |
          echo "::warning::Release rollback completed. Summary:"
          echo "- Git tag deletion attempted"
          if [ "${{ needs.create-release.result }}" == "failure" ]; then
            echo "- GitHub release deletion attempted"
          fi
          if [ "${{ needs.publish-pypi.result }}" == "success" ]; then
            echo "- PyPI package yanked (prevents new installs)"
          fi
          echo "- Release branch cleanup attempted"
          echo ""
          if [ "${{ needs.publish-pypi.result }}" == "success" ]; then
            echo "::notice::PyPI package has been yanked. New installations will be blocked,"
            echo "  but existing installations will continue to work."
          else
            echo "::error::Note: PyPI packages cannot be deleted once published."
            echo "  If the PyPI publish succeeded but other steps failed,"
            echo "  the package will remain on PyPI."
            echo "You may need to:"
            echo "  1. Create a new version to replace the failed release"
            echo "  2. Document the issue in the release notes"
            echo "  3. Consider yanking the version on PyPI if needed"
            echo "     (yanking prevents new installs but keeps existing ones)"
          fi

